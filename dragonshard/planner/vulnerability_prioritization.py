#!/usr/bin/env python3
"""
DragonShard Vulnerability Prioritization Module

Provides intelligent vulnerability prioritization and risk scoring
based on multiple factors including impact, complexity, and exploitability.
"""

import logging
import math
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

from .chain_planner import AttackType, AttackComplexity, AttackImpact, Vulnerability

logger = logging.getLogger(__name__)


class RiskLevel(Enum):
    """Risk levels for vulnerabilities."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class VulnerabilityScore:
    """Represents a scored vulnerability."""
    vulnerability: Vulnerability
    risk_score: float
    risk_level: RiskLevel
    exploitability_score: float
    impact_score: float
    complexity_score: float
    confidence_score: float
    priority_rank: int
    remediation_priority: int
    estimated_time_to_exploit: int  # minutes
    business_impact: str
    technical_impact: str


class VulnerabilityPrioritizer:
    """
    Intelligent vulnerability prioritization engine that ranks
    vulnerabilities based on multiple risk factors.
    """

    def __init__(self):
        """Initialize the vulnerability prioritizer."""
        self.impact_weights = self._load_impact_weights()
        self.complexity_weights = self._load_complexity_weights()
        self.exploitability_factors = self._load_exploitability_factors()
        self.business_impact_matrix = self._load_business_impact_matrix()
        
        logger.info("VulnerabilityPrioritizer initialized successfully")

    def _load_impact_weights(self) -> Dict[AttackImpact, float]:
        """Load impact weighting factors."""
        return {
            AttackImpact.CRITICAL: 4.0,
            AttackImpact.HIGH: 3.0,
            AttackImpact.MEDIUM: 2.0,
            AttackImpact.LOW: 1.0
        }

    def _load_complexity_weights(self) -> Dict[AttackComplexity, float]:
        """Load complexity weighting factors."""
        return {
            AttackComplexity.CRITICAL: 4.0,
            AttackComplexity.HIGH: 3.0,
            AttackComplexity.MEDIUM: 2.0,
            AttackComplexity.LOW: 1.0
        }

    def _load_exploitability_factors(self) -> Dict[AttackType, float]:
        """Load exploitability factors for different vulnerability types."""
        return {
            AttackType.SQL_INJECTION: 0.8,
            AttackType.XSS: 0.6,
            AttackType.COMMAND_INJECTION: 0.9,
            AttackType.PATH_TRAVERSAL: 0.7,
            AttackType.LFI: 0.8,
            AttackType.RFI: 0.7,
            AttackType.XXE: 0.6,
            AttackType.SSRF: 0.7,
            AttackType.TEMPLATE_INJECTION: 0.8,
            AttackType.NOSQL_INJECTION: 0.7,
            AttackType.AUTHENTICATION_BYPASS: 0.9,
            AttackType.PRIVILEGE_ESCALATION: 0.8,
            AttackType.DATA_EXFILTRATION: 0.7,
            AttackType.REMOTE_CODE_EXECUTION: 0.9
        }

    def _load_business_impact_matrix(self) -> Dict[str, Dict[str, float]]:
        """Load business impact scoring matrix."""
        return {
            "data_breach": {
                "financial": 0.9,
                "reputation": 0.8,
                "compliance": 0.9,
                "operational": 0.7
            },
            "system_compromise": {
                "financial": 0.8,
                "reputation": 0.7,
                "compliance": 0.8,
                "operational": 0.9
            },
            "service_disruption": {
                "financial": 0.6,
                "reputation": 0.5,
                "compliance": 0.4,
                "operational": 0.8
            },
            "information_disclosure": {
                "financial": 0.5,
                "reputation": 0.6,
                "compliance": 0.7,
                "operational": 0.4
            }
        }

    def calculate_risk_score(self, vulnerability: Vulnerability) -> float:
        """
        Calculate comprehensive risk score for a vulnerability.

        Args:
            vulnerability: The vulnerability to score

        Returns:
            Risk score between 0.0 and 10.0
        """
        # Base scores
        impact_score = self.impact_weights.get(vulnerability.impact, 1.0)
        complexity_score = self.complexity_weights.get(vulnerability.complexity, 1.0)
        exploitability_score = vulnerability.exploitability
        confidence_score = vulnerability.confidence

        # Vulnerability type factor
        type_factor = self.exploitability_factors.get(vulnerability.vulnerability_type, 0.5)

        # Calculate weighted risk score
        risk_score = (
            impact_score * 0.3 +
            complexity_score * 0.2 +
            exploitability_score * 0.25 +
            confidence_score * 0.15 +
            type_factor * 0.1
        ) * 4.0  # Scale to 0-10 range with higher values

        return min(risk_score, 10.0)

    def determine_risk_level(self, risk_score: float) -> RiskLevel:
        """
        Determine risk level based on risk score.

        Args:
            risk_score: The calculated risk score

        Returns:
            RiskLevel enum value
        """
        if risk_score >= 8.0:
            return RiskLevel.CRITICAL
        elif risk_score >= 6.0:
            return RiskLevel.HIGH
        elif risk_score >= 4.0:
            return RiskLevel.MEDIUM
        elif risk_score >= 2.0:
            return RiskLevel.LOW
        else:
            return RiskLevel.INFO

    def calculate_exploitability_score(self, vulnerability: Vulnerability) -> float:
        """
        Calculate exploitability score for a vulnerability.

        Args:
            vulnerability: The vulnerability to score

        Returns:
            Exploitability score between 0.0 and 1.0
        """
        base_score = vulnerability.exploitability
        type_factor = self.exploitability_factors.get(vulnerability.vulnerability_type, 0.5)
        complexity_factor = 1.0 - (self.complexity_weights.get(vulnerability.complexity, 2.0) - 1.0) / 3.0

        exploitability_score = base_score * type_factor * complexity_factor
        return min(exploitability_score, 1.0)

    def calculate_impact_score(self, vulnerability: Vulnerability) -> float:
        """
        Calculate impact score for a vulnerability.

        Args:
            vulnerability: The vulnerability to score

        Returns:
            Impact score between 0.0 and 1.0
        """
        impact_score = self.impact_weights.get(vulnerability.impact, 1.0) / 4.0
        
        # Additional impact factors based on vulnerability type
        type_impact_factors = {
            AttackType.SQL_INJECTION: 0.9,  # High data breach potential
            AttackType.COMMAND_INJECTION: 1.0,  # Complete system compromise
            AttackType.REMOTE_CODE_EXECUTION: 1.0,  # Complete system compromise
            AttackType.AUTHENTICATION_BYPASS: 0.8,  # Unauthorized access
            AttackType.PRIVILEGE_ESCALATION: 0.9,  # Elevated privileges
            AttackType.DATA_EXFILTRATION: 0.8,  # Data breach
            AttackType.XSS: 0.6,  # Session hijacking potential
            AttackType.PATH_TRAVERSAL: 0.7,  # Information disclosure
            AttackType.LFI: 0.8,  # Information disclosure
            AttackType.RFI: 0.7,  # Remote code execution potential
            AttackType.XXE: 0.6,  # Information disclosure
            AttackType.SSRF: 0.7,  # Internal network access
            AttackType.TEMPLATE_INJECTION: 0.8,  # Code execution
            AttackType.NOSQL_INJECTION: 0.7  # Data manipulation
        }

        type_factor = type_impact_factors.get(vulnerability.vulnerability_type, 0.5)
        final_impact_score = impact_score * type_factor

        return min(final_impact_score, 1.0)

    def calculate_complexity_score(self, vulnerability: Vulnerability) -> float:
        """
        Calculate complexity score for a vulnerability.

        Args:
            vulnerability: The vulnerability to score

        Returns:
            Complexity score between 0.0 and 1.0
        """
        complexity_score = self.complexity_weights.get(vulnerability.complexity, 2.0) / 4.0
        
        # Additional complexity factors
        type_complexity_factors = {
            AttackType.SQL_INJECTION: 0.6,  # Medium complexity
            AttackType.XSS: 0.4,  # Low complexity
            AttackType.COMMAND_INJECTION: 0.8,  # High complexity
            AttackType.PATH_TRAVERSAL: 0.5,  # Medium complexity
            AttackType.AUTHENTICATION_BYPASS: 0.7,  # Medium-high complexity
            AttackType.PRIVILEGE_ESCALATION: 0.8,  # High complexity
            AttackType.REMOTE_CODE_EXECUTION: 0.9,  # Very high complexity
            AttackType.DATA_EXFILTRATION: 0.6,  # Medium complexity
            AttackType.LFI: 0.5,  # Medium complexity
            AttackType.RFI: 0.6,  # Medium complexity
            AttackType.XXE: 0.7,  # Medium-high complexity
            AttackType.SSRF: 0.6,  # Medium complexity
            AttackType.TEMPLATE_INJECTION: 0.7,  # Medium-high complexity
            AttackType.NOSQL_INJECTION: 0.6  # Medium complexity
        }

        type_factor = type_complexity_factors.get(vulnerability.vulnerability_type, 0.5)
        final_complexity_score = complexity_score * type_factor

        return min(final_complexity_score, 1.0)

    def estimate_time_to_exploit(self, vulnerability: Vulnerability) -> int:
        """
        Estimate time to exploit a vulnerability in minutes.

        Args:
            vulnerability: The vulnerability to estimate

        Returns:
            Estimated time in minutes
        """
        base_times = {
            AttackType.SQL_INJECTION: 30,
            AttackType.XSS: 15,
            AttackType.COMMAND_INJECTION: 60,
            AttackType.PATH_TRAVERSAL: 20,
            AttackType.LFI: 25,
            AttackType.RFI: 45,
            AttackType.XXE: 40,
            AttackType.SSRF: 35,
            AttackType.TEMPLATE_INJECTION: 50,
            AttackType.NOSQL_INJECTION: 30,
            AttackType.AUTHENTICATION_BYPASS: 45,
            AttackType.PRIVILEGE_ESCALATION: 90,
            AttackType.DATA_EXFILTRATION: 60,
            AttackType.REMOTE_CODE_EXECUTION: 120
        }

        base_time = base_times.get(vulnerability.vulnerability_type, 30)
        
        # Adjust based on complexity
        complexity_multiplier = {
            AttackComplexity.LOW: 0.5,
            AttackComplexity.MEDIUM: 1.0,
            AttackComplexity.HIGH: 1.5,
            AttackComplexity.CRITICAL: 2.0
        }.get(vulnerability.complexity, 1.0)

        # Adjust based on confidence
        confidence_multiplier = 1.0 + (1.0 - vulnerability.confidence) * 0.5

        estimated_time = int(base_time * complexity_multiplier * confidence_multiplier)
        return max(estimated_time, 5)  # Minimum 5 minutes

    def assess_business_impact(self, vulnerability: Vulnerability) -> str:
        """
        Assess business impact of a vulnerability.

        Args:
            vulnerability: The vulnerability to assess

        Returns:
            Business impact description
        """
        impact_descriptions = {
            AttackType.SQL_INJECTION: "Potential data breach and database compromise",
            AttackType.XSS: "Session hijacking and data theft potential",
            AttackType.COMMAND_INJECTION: "Complete system compromise and data breach",
            AttackType.PATH_TRAVERSAL: "Sensitive information disclosure",
            AttackType.LFI: "Sensitive file access and information disclosure",
            AttackType.RFI: "Remote code execution and system compromise",
            AttackType.XXE: "Information disclosure and potential data exfiltration",
            AttackType.SSRF: "Internal network access and service enumeration",
            AttackType.TEMPLATE_INJECTION: "Code execution and system compromise",
            AttackType.NOSQL_INJECTION: "Data manipulation and potential data breach",
            AttackType.AUTHENTICATION_BYPASS: "Unauthorized access to protected resources",
            AttackType.PRIVILEGE_ESCALATION: "Elevated privileges and system compromise",
            AttackType.DATA_EXFILTRATION: "Sensitive data theft and privacy violation",
            AttackType.REMOTE_CODE_EXECUTION: "Complete system compromise and data breach"
        }

        return impact_descriptions.get(vulnerability.vulnerability_type, "Unknown impact")

    def assess_technical_impact(self, vulnerability: Vulnerability) -> str:
        """
        Assess technical impact of a vulnerability.

        Args:
            vulnerability: The vulnerability to assess

        Returns:
            Technical impact description
        """
        technical_impacts = {
            AttackType.SQL_INJECTION: "Database compromise, data manipulation, privilege escalation",
            AttackType.XSS: "Client-side code execution, session hijacking, data theft",
            AttackType.COMMAND_INJECTION: "System command execution, shell access, persistence",
            AttackType.PATH_TRAVERSAL: "File system access, sensitive file reading",
            AttackType.LFI: "Local file inclusion, code execution, information disclosure",
            AttackType.RFI: "Remote file inclusion, code execution, system compromise",
            AttackType.XXE: "XML external entity processing, information disclosure",
            AttackType.SSRF: "Server-side request forgery, internal network access",
            AttackType.TEMPLATE_INJECTION: "Template engine code execution, system compromise",
            AttackType.NOSQL_INJECTION: "NoSQL database manipulation, data breach",
            AttackType.AUTHENTICATION_BYPASS: "Authentication mechanism bypass, unauthorized access",
            AttackType.PRIVILEGE_ESCALATION: "Elevated system privileges, administrative access",
            AttackType.DATA_EXFILTRATION: "Sensitive data extraction, privacy violation",
            AttackType.REMOTE_CODE_EXECUTION: "Remote code execution, complete system compromise"
        }

        return technical_impacts.get(vulnerability.vulnerability_type, "Unknown technical impact")

    def prioritize_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[VulnerabilityScore]:
        """
        Prioritize a list of vulnerabilities by risk and impact.

        Args:
            vulnerabilities: List of vulnerabilities to prioritize

        Returns:
            List of VulnerabilityScore objects sorted by priority
        """
        scored_vulnerabilities = []

        for vulnerability in vulnerabilities:
            # Calculate all scores
            risk_score = self.calculate_risk_score(vulnerability)
            risk_level = self.determine_risk_level(risk_score)
            exploitability_score = self.calculate_exploitability_score(vulnerability)
            impact_score = self.calculate_impact_score(vulnerability)
            complexity_score = self.calculate_complexity_score(vulnerability)
            confidence_score = vulnerability.confidence
            estimated_time = self.estimate_time_to_exploit(vulnerability)
            business_impact = self.assess_business_impact(vulnerability)
            technical_impact = self.assess_technical_impact(vulnerability)

            # Create vulnerability score
            vuln_score = VulnerabilityScore(
                vulnerability=vulnerability,
                risk_score=risk_score,
                risk_level=risk_level,
                exploitability_score=exploitability_score,
                impact_score=impact_score,
                complexity_score=complexity_score,
                confidence_score=confidence_score,
                priority_rank=0,  # Will be set after sorting
                remediation_priority=0,  # Will be set after sorting
                estimated_time_to_exploit=estimated_time,
                business_impact=business_impact,
                technical_impact=technical_impact
            )

            scored_vulnerabilities.append(vuln_score)

        # Sort by risk score (descending)
        scored_vulnerabilities.sort(key=lambda x: x.risk_score, reverse=True)

        # Assign priority ranks
        for i, vuln_score in enumerate(scored_vulnerabilities):
            vuln_score.priority_rank = i + 1
            vuln_score.remediation_priority = i + 1

        logger.info(f"Prioritized {len(scored_vulnerabilities)} vulnerabilities")
        return scored_vulnerabilities

    def get_critical_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """
        Get vulnerabilities with critical risk level.

        Args:
            vulnerabilities: List of vulnerabilities to filter

        Returns:
            List of critical vulnerabilities
        """
        scored_vulns = self.prioritize_vulnerabilities(vulnerabilities)
        critical_vulns = [vs.vulnerability for vs in scored_vulns if vs.risk_level == RiskLevel.CRITICAL]
        return critical_vulns

    def get_high_risk_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """
        Get vulnerabilities with high or critical risk level.

        Args:
            vulnerabilities: List of vulnerabilities to filter

        Returns:
            List of high-risk vulnerabilities
        """
        scored_vulns = self.prioritize_vulnerabilities(vulnerabilities)
        high_risk_vulns = [vs.vulnerability for vs in scored_vulns 
                          if vs.risk_level in [RiskLevel.HIGH, RiskLevel.CRITICAL]]
        return high_risk_vulns

    def generate_prioritization_report(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """
        Generate a comprehensive prioritization report.

        Args:
            vulnerabilities: List of vulnerabilities to analyze

        Returns:
            Prioritization report with statistics and recommendations
        """
        scored_vulns = self.prioritize_vulnerabilities(vulnerabilities)

        # Calculate statistics
        total_vulns = len(scored_vulns)
        critical_count = len([v for v in scored_vulns if v.risk_level == RiskLevel.CRITICAL])
        high_count = len([v for v in scored_vulns if v.risk_level == RiskLevel.HIGH])
        medium_count = len([v for v in scored_vulns if v.risk_level == RiskLevel.MEDIUM])
        low_count = len([v for v in scored_vulns if v.risk_level == RiskLevel.LOW])

        # Calculate average scores
        avg_risk_score = sum(v.risk_score for v in scored_vulns) / total_vulns if total_vulns > 0 else 0
        avg_exploitability = sum(v.exploitability_score for v in scored_vulns) / total_vulns if total_vulns > 0 else 0
        avg_impact = sum(v.impact_score for v in scored_vulns) / total_vulns if total_vulns > 0 else 0

        # Generate recommendations
        recommendations = self._generate_prioritization_recommendations(scored_vulns)

        report = {
            "summary": {
                "total_vulnerabilities": total_vulns,
                "critical_vulnerabilities": critical_count,
                "high_vulnerabilities": high_count,
                "medium_vulnerabilities": medium_count,
                "low_vulnerabilities": low_count,
                "average_risk_score": round(avg_risk_score, 2),
                "average_exploitability": round(avg_exploitability, 2),
                "average_impact": round(avg_impact, 2)
            },
            "top_vulnerabilities": [
                {
                    "rank": v.priority_rank,
                    "type": v.vulnerability.vulnerability_type.value,
                    "target": v.vulnerability.target_url,
                    "risk_score": round(v.risk_score, 2),
                    "risk_level": v.risk_level.value,
                    "estimated_time": v.estimated_time_to_exploit,
                    "business_impact": v.business_impact
                }
                for v in scored_vulns[:10]  # Top 10
            ],
            "recommendations": recommendations,
            "detailed_scores": [
                {
                    "rank": v.priority_rank,
                    "type": v.vulnerability.vulnerability_type.value,
                    "target": v.vulnerability.target_url,
                    "risk_score": round(v.risk_score, 2),
                    "risk_level": v.risk_level.value,
                    "exploitability_score": round(v.exploitability_score, 2),
                    "impact_score": round(v.impact_score, 2),
                    "complexity_score": round(v.complexity_score, 2),
                    "confidence_score": round(v.confidence_score, 2),
                    "estimated_time": v.estimated_time_to_exploit,
                    "business_impact": v.business_impact,
                    "technical_impact": v.technical_impact
                }
                for v in scored_vulns
            ]
        }

        return report

    def _generate_prioritization_recommendations(self, scored_vulns: List[VulnerabilityScore]) -> List[str]:
        """Generate recommendations based on vulnerability prioritization."""
        recommendations = []

        critical_vulns = [v for v in scored_vulns if v.risk_level == RiskLevel.CRITICAL]
        high_vulns = [v for v in scored_vulns if v.risk_level == RiskLevel.HIGH]

        if critical_vulns:
            recommendations.append(f"Immediate remediation required for {len(critical_vulns)} critical vulnerabilities")

        if high_vulns:
            recommendations.append(f"High priority remediation for {len(high_vulns)} high-risk vulnerabilities")

        # Type-specific recommendations
        vuln_types = [v.vulnerability.vulnerability_type for v in scored_vulns]
        
        if AttackType.SQL_INJECTION in vuln_types:
            recommendations.append("Implement input validation and parameterized queries for SQL injection vulnerabilities")

        if AttackType.COMMAND_INJECTION in vuln_types:
            recommendations.append("Immediate action required for command injection vulnerabilities - high system compromise risk")

        if AttackType.AUTHENTICATION_BYPASS in vuln_types:
            recommendations.append("Review and strengthen authentication mechanisms")

        if len(scored_vulns) > 10:
            recommendations.append("Consider comprehensive security audit and penetration testing")

        return recommendations


if __name__ == "__main__":
    # Example usage
    import logging
    logging.basicConfig(level=logging.INFO)

    # Initialize prioritizer
    prioritizer = VulnerabilityPrioritizer()

    # Sample vulnerabilities
    sample_vulns = [
        Vulnerability(
            target_url="http://example.com/search.php",
            vulnerability_type=AttackType.SQL_INJECTION,
            payload="' OR 1=1--",
            confidence=0.9,
            evidence="SQL syntax error in response",
            impact=AttackImpact.HIGH,
            complexity=AttackComplexity.MEDIUM,
            exploitability=0.8,
            description="SQL injection vulnerability in search parameter",
            remediation="Use parameterized queries"
        ),
        Vulnerability(
            target_url="http://example.com/comment.php",
            vulnerability_type=AttackType.XSS,
            payload="<script>alert('XSS')</script>",
            confidence=0.7,
            evidence="JavaScript executed in response",
            impact=AttackImpact.MEDIUM,
            complexity=AttackComplexity.LOW,
            exploitability=0.6,
            description="Reflected XSS vulnerability",
            remediation="Implement output encoding"
        ),
        Vulnerability(
            target_url="http://example.com/upload.php",
            vulnerability_type=AttackType.COMMAND_INJECTION,
            payload="; ls -la",
            confidence=0.8,
            evidence="Command output in response",
            impact=AttackImpact.CRITICAL,
            complexity=AttackComplexity.HIGH,
            exploitability=0.9,
            description="Command injection vulnerability",
            remediation="Avoid command execution"
        )
    ]

    # Prioritize vulnerabilities
    scored_vulns = prioritizer.prioritize_vulnerabilities(sample_vulns)
    
    print("Vulnerability Prioritization Results:")
    for vuln_score in scored_vulns:
        print(f"Rank {vuln_score.priority_rank}: {vuln_score.vulnerability.vulnerability_type.value} "
              f"(Risk: {vuln_score.risk_score:.2f}, Level: {vuln_score.risk_level.value})")

    # Generate report
    report = prioritizer.generate_prioritization_report(sample_vulns)
    print(f"\nReport Summary: {report['summary']}") 